# 设计结构

### 1.启动

  创建Server对象，并传递服务器参数

* -p 	port:端口号
* -b     backlog: 套接字等待连接队列的大小
* -o     timeout:长连接下的最大连接时间，单位毫秒
* -t      threadNum:线程池中线程的数目
* -r      filePath:资源文件的根路径

## 2.初始化服务器

* 初始化服务器中的epoll，计时器，线程池和套接字。由于程序工作在ET模式下，套接字要设置为非阻塞
* 将套接字放入epoll，监听连接

## 3.事件的监听

* 每个客户端socket都交由Httpconnect类管理，该类包含了一个时钟对象(Timer)用于记录超时时间

* 计时器使用stl库中的优先队列(堆)存放Timer，队首元素的超时时间最靠前

* 服务器每次循环向计时器询问最近未超时的时间并调用epoll的wait，若不存在未超时时钟，则一直阻塞直到有新的连接。

* 当有新事件出现时，可能有如下情况:

  * 新的连接:事件的socket就是服务器soket，调用AcceptConnect函数接收连接。连接过程短，无需放入线程池。
  * 错误事件:发生错误(如对方已经断开连接)直接关闭该socket
  
  * 读事件:将服务器的HttpRecv函数放入线程池
  * 写事件:将服务器的HttpSend函数放入线程池

## 4.事件的处理

* 接收连接：由于ET触发，服务器socket必须设为非阻塞并一直读到EAGAIN为止

* 读事件的处理:

  * 先将socket置为工作状态，防止执行过程中计时器删除了该socket，写事件同理。

  * 调用Httpconnect::ReadSock函数，循环读入数据。可能出现的结果有未读到数据但连接仍在，未读到数据且连接断开，读到数据三种情况，应对策略分别是直接返回、断开连接、解析报文

  * 若读到数据，则调用ProcessRequset函数解析报文将解析到的协议版本、url、查询条件以及请求头的各项参数保存，用于后续确定发送的内容。

  * 若解析成功，将状态码200对应的报文内容添加到该socket对应的写数据缓存队列末尾

* 写事件的处理

  * 先将socket置为工作状态

  * 调用Httpconnect::WriteSock函数，将已经在缓存队列的一个响应报文发出。若发送失败，断开连接。若发送成功，根据请求是否是keep-alive决定是否立刻断开连接。如果保持连接，必须将socket上次读入的状态清除，防止影响到下次读数据。

## 5.重要细节

* 超时管理:只有当时钟超时且时钟未失效且socket处于未工作状态，才有权限删除socket。否则均为服务器对Socket进行删除。这也是为什么socket在读和写之前要先置为工作状态，防止在工作时钟将其删除。
* 时钟的删除:时钟只有设置失效的方法没有直接删除的方法，这么做是为了防止优先队列出现空指针。而时钟的存储采用的是智能指针，保证其被计时器弹出时析构。







